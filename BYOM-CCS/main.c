// A simple brushless motor driver.

#include <math.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

#include "inc/hw_ints.h"
#include "inc/hw_memmap.h"
#include "inc/hw_timer.h"
#include "inc/hw_types.h"
#include "inc/hw_uart.h"

#include "driverlib/fpu.h"
#include "driverlib/gpio.h"
#include "driverlib/interrupt.h"
#include "driverlib/pin_map.h"
#include "driverlib/sysctl.h"
#include "driverlib/systick.h"
#include "driverlib/timer.h"
#include "driverlib/uart.h"

#include "utils/uartstdio.h"

#include "bldc.h"
#include "drv8323rs.h"

// Frequency of timer A0 interrupt (in Hz)
#define LOG_FREQ 5000

// Number of samples to record
#define NUM_SAMPLES 15000

 // Global test data array
volatile uint16_t logData[NUM_SAMPLES];

// Global flag set when logging completes
volatile bool doneLogging = 0;

// Global counter of the number of samples logged
volatile uint16_t logCount = 0;


// Sets up UART0 to be used for a console to display info as the programs runs.
void InitConsole(void) {
    // Enable GPIO port A which is used for UART0 pins, and enable UART0
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);

    // Pin configuration
    GPIOPinConfigure(GPIO_PA0_U0RX);
    GPIOPinConfigure(GPIO_PA1_U0TX);

    // Select the alternate (UART) function
    GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);

    // Use the internal 16MHz oscillator as the UART
    UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);

    // Initialize the UART for console I/O
    UARTStdioConfig(0, 115200, SysCtlClockGet());

    // Print debug information
    UARTprintf("\n\nConsole on UART0 is up.\n");
}


// The interrupt handler for the periodic interrupt generated by Timer A0
void LogInterruptHandler(void) {
    // Clear the timer interrupt
    TimerIntClear(TIMER0_BASE, TIMER_TIMA_TIMEOUT);

    // Toggle pin B0, to permit validation of log frequency on oscilloscope
    if (GPIOPinRead(GPIO_PORTB_BASE, GPIO_PIN_0))
        GPIOPinWrite(GPIO_PORTB_BASE, GPIO_PIN_0, 0);
    else
        GPIOPinWrite(GPIO_PORTB_BASE, GPIO_PIN_0, GPIO_PIN_0);

    // Log until the array is full
    if(logCount < NUM_SAMPLES) {
        // Log the current and the hall state as a single 16-bit quantity
        logData[logCount] = GetCurrent() + (HallState << 12);

        logCount++;
    }
    else
        doneLogging = 1;
}


// This function sets up timer A0 to generate interrupts at frequency specified by LOG_FREQ
void LogTimerSetup(void) {
    // Enable Timer 0
    SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0);

    // Enable processor interrupts
    IntMasterEnable();

    // Configure the timer as a 32-bit periodic timer
    TimerConfigure(TIMER0_BASE, TIMER_CFG_PERIODIC);

    // Set the timer load value
    TimerLoadSet(TIMER0_BASE, TIMER_A, SysCtlClockGet() / LOG_FREQ);

    // Enable timer A0 interrupts, set the timer A0 interrupt priority to be "low"
    IntEnable(INT_TIMER0A);
    IntPrioritySet(INT_TIMER0A, 0x20);

    // Enable the specific interrupt we want (timeout interrupt), and register the interrupt service routine
    TimerIntEnable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);
    TimerIntRegister(TIMER0_BASE, TIMER_A,LogInterruptHandler);

    // Enable GPIO port B
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);
    while(!SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOB));

    // Set pin B0 as an output, and initialize it to LOW
    GPIOPinTypeGPIOOutput(GPIO_PORTB_BASE, GPIO_PIN_0);
    GPIOPinWrite(GPIO_PORTB_BASE, GPIO_PIN_0, 0);

    // Enable the timer
    TimerEnable(TIMER0_BASE, TIMER_A);
}


// Main function:
int main(void) {

    FPULazyStackingEnable(); // Allow interrupt handlers to use floating-point instructions at the expense of extra stack usage

    // Set the clocking to run directly from the external crystal/oscillator:
    SysCtlClockSet(SYSCTL_SYSDIV_1 | SYSCTL_USE_OSC | SYSCTL_OSC_MAIN | SYSCTL_XTAL_16MHZ);

    // Set up the serial console
    InitConsole();
    UARTprintf("Console initialized.\n");

    // Set up brushless motor control
    UARTprintf("Setting up motor drive...\n");
    MotorSetup();

    // Start the log interrupt
    UARTprintf("Setting up log timer...\n");
    LogTimerSetup();

    // Read the hall state and commutate once to force the motor to start turning
    MotorCommutate(DUTY_CYCLE);

	while(1)
	{
	    if(doneLogging) {
	        int i;

	        UARTprintf("Hall state, Current(counts)\n");
	        for(i=0; i<NUM_SAMPLES; i++) {
                UARTprintf("\t%d,%d\n", (logData[i] & 0xF000) >> 12, logData[i] & 0x0FFF);
	        }
	        break;
	    }
	}

    return 0;
}
